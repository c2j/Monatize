use std::env;
use std::fs;
use std::path::PathBuf;

use sha2::{Digest, Sha256};

fn main() {
    // Simple codegen: read idl files (concatenate) and generate fixed struct definitions
    let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let idl_dir = crate_dir.join("idl");
    let mut idl_concat = String::new();
    if let Ok(entries) = fs::read_dir(&idl_dir) {
        for e in entries.flatten() {
            if let Ok(content) = fs::read_to_string(e.path()) {
                idl_concat.push_str(&content);
                idl_concat.push('\n');
            }
        }
    }

    let mut hasher = Sha256::new();
    hasher.update(idl_concat.as_bytes());
    let hash = hasher.finalize();
    let hash_hex = format!("{:x}", hash);

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let gen_path = out_dir.join("generated.rs");

    let code = format!(
        r#"// @generated by build.rs
// IDL hash: {hash_hex}
use serde::{{Serialize, Deserialize}};
use bytes::Bytes;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpRequest {{ pub url: String }}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpResponse {{ pub status: u16, pub headers: Vec<(String, String)>, pub body: Bytes }}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DisplayList {{ pub items: Vec<DrawCmd> }}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum DrawCmd {{
    Rect {{ x: u32, y: u32, w: u32, h: u32, rgba: u32 }},
}}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct AiRequest {{ pub prompt: String, pub max_tokens: u32 }}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct AiResponse {{ pub text: String }}

pub const GEN_HASH: &str = "{hash_hex}";
"#
    );

    fs::write(&gen_path, code).expect("write generated.rs");
    println!("cargo:rerun-if-changed={}", idl_dir.display());
}

